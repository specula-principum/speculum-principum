"""Structure generation helpers for the knowledge base."""
from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Iterator, Mapping, Sequence

DEFAULT_STRUCTURE: Mapping[str, object] = {
    "index.md": "# {title}\n\n{description}\n",
    "metadata.yaml": None,
    "taxonomy.yaml": None,
    "concepts": {
        "index.md": "# Concepts\n\nUse this hub to navigate topical concepts.\n",
    },
    "entities": {
        "index.md": "# Entities\n\nDirectory of people, places, and organizations.\n",
    },
    "sources": {
        "index.md": "# Sources\n\nPrimary and secondary source materials.\n",
    },
    "relationships": {
        "index.md": "# Relationships\n\nGraph connections between artifacts.\n",
    },
    "meta": {
        "methodology.md": None,
        "conventions.md": None,
        "quality-standards.md": None,
        "processing-history.yaml": None,
    },
}

DEFAULT_CONTEXT: Mapping[str, str] = {
    "title": "Knowledge Base",
    "description": "Map of content generated by Speculum Principum.",
}

@dataclass(slots=True)
class StructureNode:
    """Represents a node in the structure blueprint."""

    path: Path
    children: Mapping[str, object] | None
    template: str | None = None


@dataclass(slots=True)
class PlannedNode:
    """Planned materialization entry for directory or file."""

    path: Path
    is_directory: bool
    content: str | None = None


def iter_structure(root: Path, structure: Mapping[str, object] | None = None) -> Iterator[StructureNode]:
    """Yield blueprint nodes for the desired knowledge base layout."""

    layout = DEFAULT_STRUCTURE if structure is None else structure
    for name, nested in layout.items():
        node_path = root / name
        if isinstance(nested, Mapping):
            yield StructureNode(path=node_path, children=nested)
            yield from iter_structure(node_path, nested)
        else:
            template = nested if isinstance(nested, str) else None
            yield StructureNode(path=node_path, children=None, template=template)


def required_directories(structure: Mapping[str, object] | None = None) -> Sequence[str]:
    """Return directory names that must exist under the knowledge base root."""

    layout = DEFAULT_STRUCTURE if structure is None else structure
    directories: list[str] = []
    for name, nested in layout.items():
        if isinstance(nested, Mapping):
            directories.append(name)
    return tuple(directories)


def render_templates(node: StructureNode, context: Mapping[str, str]) -> str | None:
    """Render node template content when defined."""

    if node.template is None:
        return None
    try:
        return node.template.format_map(context)
    except KeyError as error:
        missing = error.args[0]
        raise ValueError(f"Missing template context value for {missing!r}.") from error


def plan_structure(
    root: Path,
    *,
    structure: Mapping[str, object] | None = None,
    context: Mapping[str, str] | None = None,
) -> tuple[PlannedNode, ...]:
    """Plan the knowledge base structure for later materialization."""

    layout = DEFAULT_STRUCTURE if structure is None else structure
    ctx: dict[str, str] = dict(DEFAULT_CONTEXT)
    if context:
        ctx.update(context)
    planned: list[PlannedNode] = []
    for node in iter_structure(root, layout):
        if node.children is not None:
            planned.append(PlannedNode(path=node.path, is_directory=True))
        else:
            content = render_templates(node, ctx)
            planned.append(PlannedNode(path=node.path, is_directory=False, content=content))
    return tuple(planned)


def materialize_structure(plan: Iterable[PlannedNode], *, force: bool = False) -> list[Path]:
    """Create the planned structure on disk."""

    created: list[Path] = []
    for item in plan:
        if item.is_directory:
            item.path.mkdir(parents=True, exist_ok=True)
            created.append(item.path)
            continue
        item.path.parent.mkdir(parents=True, exist_ok=True)
        if item.path.exists() and not force:
            created.append(item.path)
            continue
        if item.content is None:
            item.path.touch(exist_ok=True)
        else:
            item.path.write_text(item.content, encoding="utf-8")
        created.append(item.path)
    return created
